---
title: "Stats. Inference Assignment 3"
author: "Naeem Chowdhury"
date: "5/19/2020"
output: pdf_document
---


##1. Setup
### options
Set up global options
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_chunk$set(tidy=TRUE)
knitr::opts_chunk$set(tidy.opts=list(width.cutoff=70))
knitr::opts_chunk$set(fig.height=4, fig.width=6)
```

### libraries
Load in needed libraries 
```{r}
library(tidyverse)
library(RColorBrewer)
library(haven)
```

## 2. File management
### Create variables for directories
```{r file_management}
project.dir <- getwd() #naeem
output.dir <- "/Output"
data.dir <- "C:/Users/Naeem Cho/Desktop/School Work/Statistical Inference/Datasets"
setwd(project.dir)
getwd()
```

## 3. Importing Data
```{r}
cpu.data <- read_csv(file.path(data.dir, "Intel_CPUs.csv"))
```

# Problem #1

## 1. Code up your own _my.chisq.test()_ function that will perform a $\chi^2$ test. As a single argument, it should just take a contingency table of arbitrary size. As output, it should provide:

- Calculated $\chi^2$ statistic
- $p$-value

Caclulating the expected cell counts under $H_0$ hypothesis should constitute a critical part of your function definition. Don't use neither _chisq.test()_ nor _prop.test()_, nor any other "fancy cheat" built-in functions inside your function's definition.

```{r}
data <- matrix(c(18, 20, 15, 15, 10, 55, 65, 70, 30), nrow=3)

my.chisq.test <- function(ctable) {
  rows <- nrow(ctable)
  cols <- ncol(ctable)
  
  rowsums <- rowSums(ctable)
  colsums <-colSums(ctable)
  
  total <- sum(ctable)
  df <- (rows-1)*(cols-1)
  
  expected <- matrix(0, nrow = rows, ncol = cols)
  
  for(i in 1:rows){
    
    for(j in 1:cols){
      
      expected[i,j] <- (rowsums[i]*colsums[j])/ total
      
    }
  }
  chi_sq <- ((ctable - expected)^2)/expected
  chi_sq <- sum(chi_sq)
  
  p <- pchisq(chi_sq, df, lower.tail = FALSE)
  
  
  print(c("X-Squared: ",  chi_sq))
  print(c("Degrees of Freedom: ", df))
  print(c("p-value: ", p))
  # print(c("Matrix of expected counts: ", expected))
}
```

## 2. Testing on a CPU/GPU Dataset


### a. What variables are we interested in?

```{r}
vert_stat <- cpu.data %>% select(Vertical_Segment, Status) %>% drop_na()
table(vert_stat)
```
I've selected two categorical variables from the Intel_CPUs dataset which each have 4 categories. However, since the 'Announced' category and 'Embedded' category have very few variables, I've decided to drop them in order to simplify the analysis.

```{r}
vert_stat <- cpu.data %>% select(Vertical_Segment, Status) %>% filter(Vertical_Segment != 'Embedded' & Status != 'Announced') %>%  drop_na()
ctable <- table(vert_stat)
```

### b. What are the hypotheses?

$H_0$ := The launch Status of a CPU is independent of its Vertical_Segment type.

$H_a$ := The launch status of an Intel CPU is dependent on its Vertical Segment type.

### c. Print the contingency table. Under $H_0$ hypothesis, proceed to calculate expected counts for two arbitrary cells of the contingency table.

```{r}
ctable

# Calculating the expected counts for two arbitrary cells.
rows <- nrow(ctable)
cols <- ncol(ctable)
rowsums <- rowSums(ctable)
colsums <-colSums(ctable)
total <- sum(ctable)

# Produce the pairs of row and column location of arbitrary position
r.indices <- sample(1:rows, 2, replace= T)
c.indices <- sample(1:cols, 2, replace= T)
n <- sum(ctable)

n.r1 <- as.numeric(rowsums[r.indices[1]])
n.c1 <- as.numeric(colsums[c.indices[1]])

n.r2 <- as.numeric(rowsums[r.indices[2]])
n.c2 <- as.numeric(colsums[c.indices[2]])

expected1 <- (n.r1*n.c1)/n 
expected2 <- (n.r2*n.c2)/n

#Final expected counts for the two points
expected1
expected2
```

### d. Proceed to apply your _my.chisq.test()_ and interpret the results. As a sanity check, also run _R_'s built-in _chisq.test()_ function on that same data, make sure the outputted $\chi^2$ and $p$-values match with those provided by _my.chisq.test()_. 

```{r}
my.chisq.test(ctable)

chisq.test(ctable)
```

My test works everywhere except for computing the p-value, where it seems to fail. However, when I test my function on another dummy table , it seems to work just fine. What could be the issue?

```{r}
my.chisq.test(data)
chisq.test(data)
```






